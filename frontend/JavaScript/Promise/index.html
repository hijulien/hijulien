<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-frontend docs-doc-id-JavaScript/Promise">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Promise | note</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://hijulien.github.io/hijulien/frontend/JavaScript/Promise"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-frontend-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-frontend-current"><meta data-rh="true" property="og:title" content="Promise | note"><meta data-rh="true" name="description" content="Promise 含义及基本介绍"><meta data-rh="true" property="og:description" content="Promise 含义及基本介绍"><link data-rh="true" rel="icon" href="/hijulien/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://hijulien.github.io/hijulien/frontend/JavaScript/Promise"><link data-rh="true" rel="alternate" href="https://hijulien.github.io/hijulien/frontend/JavaScript/Promise" hreflang="zh"><link data-rh="true" rel="alternate" href="https://hijulien.github.io/hijulien/frontend/JavaScript/Promise" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/hijulien/blog/rss.xml" title="note RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/hijulien/blog/atom.xml" title="note Atom Feed"><link rel="stylesheet" href="/hijulien/assets/css/styles.d03fc8fd.css">
<link rel="preload" href="/hijulien/assets/js/runtime~main.223637bc.js" as="script">
<link rel="preload" href="/hijulien/assets/js/main.44331553.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/hijulien/"><div class="navbar__logo"><img src="/hijulien/img/julien.jpg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/hijulien/img/julien.jpg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Hi Julien</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/hijulien/frontend/JavaScript">frontend</a><a class="navbar__item navbar__link" href="/hijulien/backend/Linux">backend</a><a class="navbar__item navbar__link" href="/hijulien/others/Git">others</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" path="docs/something" href="/hijulien/docs/第 1 章 内存与数据结构">小专栏</a><a href="https://github.com/hijulien/notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/hijulien/frontend/JavaScript/">JavaScript</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/">Grammar</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/API">API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/Fragment">Fragment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/WebAPI">WebAPI</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/hijulien/frontend/JavaScript/Promise">Promise</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/Error">Error</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/ES6/intro">ES6</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/TypeScript/intro">TypeScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/React/">React</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/WebAPI/canvas">webAPI</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/Axios/">Axios</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/hijulien/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">JavaScript</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Promise</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Promise</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="promise-含义及基本介绍">Promise 含义及基本介绍<a href="#promise-含义及基本介绍" class="hash-link" aria-label="Promise 含义及基本介绍的直接链接" title="Promise 含义及基本介绍的直接链接">​</a></h2><p>首先 Promise 也是一个类或构造函数，是 JS 原生提供的，和我们自定义的类一样，通过对它进行实例化后，来完成预期的异步任务处理。</p><p>Promise 接受异步任务并立即执行，然后在任务完成后，将状态标注成最终结果（成功或失败）。</p><p>Promise 有三种状态：初始化时，刚开始执行主体任务，这时它的初始状态时  <strong>pending（进行中）</strong> ；等到任务执行完成，这时根据成功或失败，分别对应状态 <strong>fulfilled（成功）</strong>和  <strong>rejected（失败）</strong> ，这时的状态就固定不能被改变了，即  <strong>Promise 状态是不可逆的</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="基本用法">基本用法<a href="#基本用法" class="hash-link" aria-label="基本用法的直接链接" title="基本用法的直接链接">​</a></h3><p>Promise 就是一个类，所以使用时，我们照常 new 一个实例即可。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 这里是 Promise 主体，执行异步任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ajax(&#x27;xxx&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     resolve(&#x27;成功了&#x27;); // 或 reject(&#x27;失败了&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面创建好 Promise 实例后，里面的主体会立即执行，比如，如果是发送请求，则会立即把请求发出去，如果是定时器，则会立即启动计时。至于请求什么时候返回，我们就在返回成功的地方，通过 resolve() 将状态标注为成功即可，同时 resolve(data) 可以附带着返回数据。 然后在 then() 里面进行回调处理。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 这里是 Promise 主体，执行异步任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ajax(&#x27;xxx&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     resolve(&#x27;成功了&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">myPromise.then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // 处理 data 数据</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里需要注意的是<strong>当初始化 Promise 实例时，主体代码是同步就开始执行了的，只有 then() 里面的回调处理才是异步的，因为它需要等待主体任务执行结束。技能考察时常常会通过分析执行顺序考察此处。</strong> 如下面的代码将输出 1、3、2。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 这里是 Promise 主体，执行异步任务</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ajax(&#x27;xxx&#x27;, () =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     resolve(&#x27;成功了&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).then(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(3);// 最终输出 1、3、2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果我们在调用 then() 之前，Promise 主体里的异步任务已经执行完了，即 Promise 的状态已经标注为成功了。<strong>那么我们调用 then 的时候，并不会错过，还是会执行。但需要记着，即使主体的异步任务早就执行完了，then() 里面的回调永远是放到微任务里面异步执行的，而不是立马执行。</strong></p><p>比如我们在主体里面仅执行一块同步代码，从而不需要等待，下面代码 then() 将依然最后输出。因此我们也常常利用这种方式构建微任务（相对应的利用 setTimeout 构建宏任务）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 主体只有同步代码，则 Promise 状态会立马标注为成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).then(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 最终输出为 1、3、2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="promise-异常处理">Promise 异常处理<a href="#promise-异常处理" class="hash-link" aria-label="Promise 异常处理的直接链接" title="Promise 异常处理的直接链接">​</a></h3><ul><li><strong>方式一：通过 then() 的第 2 个参数</strong></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">myPromise.then(successCallback, errorCallback);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这种方式能捕获到 promise 主体里面的异常，并执行 errorCallback。但是如果 Promise 主体里面没有异常，然后进入到 successCallback 里面发生了异常，此时将不会进入到 errorCallback。因此我们经常使用下面的方式二来处理异常。</p><ul><li><strong>方式二：通过 catch() （常用方案）</strong></li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">myPromise.then(successCallback).catch(errorCallback);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样不管是 Promise 主体，还是 successCallback 里面的出了异常，都会进入到 errorCallback。<strong>这里需要注意，按这种链式写法才正确，如果按下面的写法将会和方式一类似，不能按预期捕获</strong>，具体原因在后面的链式调用里面说明。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">myPromise.then(successCallback);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">myPromise.catch(errorCallback);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><strong>方式三：try...catch</strong></li></ul><p>try catch 是传统的异常捕获方式，这里只能捕获同步代码的异常，并不能捕获异步异常，因此无法对 Promise 进行完整的异常捕获。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="链式调用">链式调用<a href="#链式调用" class="hash-link" aria-label="链式调用的直接链接" title="链式调用的直接链接">​</a></h3><p>熟悉 JQuery 的同学应该很了解链式调用，就是在调用了对象的一个方法后，此方法又返回了这个对象，从而可以继续在后面调用对象的方法。Promise 的链式调用，每次调用后，会返回一个新的 Promise 实例对象，从而可以继续 then()或者其他 API 调用，如上面的方式二异常处理中的 catch 就属于链式调用。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return data + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})).then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输出 2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里需要注意的是，<strong>每次 then() 或者 catch() 后，返回的是一个新的 Promise，和上一次的 Promise 实例对象已经不是同一个引用了。而这个新的 Promise 实例对象包含了上一次 then 里面的结果，这也是为什么链式调用的 catch 才能捕获到上一次 then 里面的异常的原因</strong>。</p><p>下面的代码非链式调用，每次 then 都是针对最初的 Promise 实例最后输出为 1。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const myPromise = new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">myPromise.then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return data + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">romise.then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 输出 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="常用-api">常用 API<a href="#常用-api" class="hash-link" aria-label="常用 API的直接链接" title="常用 API的直接链接">​</a></h3><p>我再对一些常用 API 进行一下简单说明和介绍，Promise API 和大部分类一样，分为<strong>实例 API 或原型方法</strong>（即 new 出来的对象上的方法），和<strong>静态 API 或类方法</strong>（即直接通过类名调用，不需要 new）。注意<strong>实例 API 都是可以通过链式调用</strong>的。</p><p><strong>实例 API（原型方法）</strong></p><ul><li>then()</li></ul><p>Promise 主体任务和在此之前的链式调用里的回调任务都成功的时候（即前面通过 resolve 标注状态后），进入本次 then() 回调。</p><ul><li>catch()</li></ul><p>Promise 主体任务和在此之前的链式调用里的出现了异常，并且在此之前未被捕获的时候（即前面通过 reject 标注状态或者出现 JS 原生报错没处理的时候），进入本次 catch()回调。</p><ul><li>finally()</li></ul><p>无论前面出现成功还是失败，最终都会执行这个方法（如果添加过）。比如某个任务无论成功还是失败，我们都希望能告诉用户任务已经执行结束了，就可以使用 finally()。</p><p><strong>静态 API（类方法）</strong></p><ul><li>Promise.resolve()</li></ul><p>返回一个成功状态的 Promise 实例，一般常用于构建微任务，比如有个耗时操作，我们不希望阻塞主程序，就把它放到微任务去，如下输出 1、3、2，即 console.log(2) 将放到最后微任务去执行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">console.log(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.resolve().then(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(2); // 作为微任务输出 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(3);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>Promise.reject()</li></ul><p>这个与 Promise.resolve 使用类似，返回一个失败状态的 Promise 实例。</p><ul><li>Promise.all()</li></ul><p>此方法接收一个数组为参数（准确说是可迭代参数），数组里面每一项都是一个单独的 Promise 实例，此方法返回一个 Promise 对象。这个返回的对象含义是数组中所有 Promise 都返回了（可失败可成功），返回 Promise 对象就算完成了。适用于需要并发执行任务时，比如同时发送多个请求。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const p1 = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const p2 = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const p3 = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const pAll = Promise.all([p1, p2, p3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pAll.then((list) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // p1,p2,p3 都成功了即都 resolve 了，会进入这里；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // list 按顺序为 p1,p2,p3 的 resolve 携带的返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).catch(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // p1,p2,p3 有至少一个失败，其他成功，就会进入这里；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>注意 Promise.all 是所有传入的值都返回状态了，才会最终进入 then 或 catch 回调。</strong></p><p>Promise 的参数也可以如下常量，它会转换成立即完成的 Promise 对象：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Promise.all([1, 2, 3]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 等同于</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const p1 = new Promise(resolve =&gt; resolve(1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const p2 = new Promise(resolve =&gt; resolve(2));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const p3 = new Promise(resolve =&gt; resolve(3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.all([p1, p2, p3]);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>Promise.race()</li></ul><p>与 Promise.all() 类似，不过区别是 Promise.race 只要传入的 Promise 对象，有一个状态变化了，就会立即结束，而不会等待其他 Promise 对象返回。所以一般用于竞速的场景。</p><p>接下来，来看看 Promise 具体的使用场景。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="promise-最佳实践介绍">Promise 最佳实践介绍<a href="#promise-最佳实践介绍" class="hash-link" aria-label="Promise 最佳实践介绍的直接链接" title="Promise 最佳实践介绍的直接链接">​</a></h2><p>Promise 的 API 不多，使用也不复杂，简单场景一看就明白，不过对于一些复杂的代码模块，不够熟悉的同学就会感觉比较绕。比如这些实际应用中的经验。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="异步-promise-化的两个关键">异步 Promise 化的两个关键<a href="#异步-promise-化的两个关键" class="hash-link" aria-label="异步 Promise 化的两个关键的直接链接" title="异步 Promise 化的两个关键的直接链接">​</a></h3><p>实际应用中，我们尽量将所有异步操作进行 Promise 的封装，方便其他地方调用。放弃以前的 callback 写法，比如我们封装了一个类 classA，里面需要有一些准备工作才能被外界使用，以前我们可能会提供 ready(callback) 方法，那么现在就可以这样 ready().then()。</p><p>另外，一般开发中，尽量将 new Promise 的操作封装在内部，而不是在业务层去实例化。</p><p>如下面代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 封装</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function getData(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const promise = new Promise((resolve,reject)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ajax(xxx, (d) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        resolve(d);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return promise</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getData().then((data)=&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>其实处理和封装异步任务关键就是两件事</strong></p><ul><li><strong>定义异步任务的执行内容。</strong>如发一个请求、设一个定时器、读取一个文件等；</li><li><strong>指出异步任务结束的时机。</strong>如请求返回时机、定时器结束的时机、文件读取完成的时机，其实就是触发回调的时机。</li></ul><p>当通过 new Promise 初始化实例的时候，就定义了异步任务的执行内容，即 Promise 主体。然后 Promise 给我们两个函数 resolve 和 reject 来让我们明确指出任务结束的时机，也就是告诉 Promise 执行的内容和结束的时机就行了，不用像 callback 那样，需要把处理过程也嵌套写在里面，而是在原来 callback 的地方调用一下 resolve（成功）或 reject（失败）来标识任务结束了。</p><p><strong>在实际开发中，不管业务模块或者老代码多么复杂，只需要抓住上述两点去进行改造，就能正确地将所有异步代码进行 Promise 化。</strong> 所有异步甚至同步逻辑都可以 Promise 化，只要抓住 任务内容和 任务结束时机这两点就可很清晰的来完成封装。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="如何避免冗余封装">如何避免冗余封装？<a href="#如何避免冗余封装" class="hash-link" aria-label="如何避免冗余封装？的直接链接" title="如何避免冗余封装？的直接链接">​</a></h3><p>现在很多类库已经支持返回 Promise 实例了，尽量避免在外面重复包装，所以在使用时仔细看官方说明，有的库既支持 callback 形式，也支持 Promise 形式。</p><p>下面代码为冗余封装：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    axios.get(url).then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      resolve(data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另一个案例就是，有时我们会需要构建微任务或者将同步执行的结果数据，以 Promise 的形式返回给业务，会容易写成下面的冗余写法：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const b = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const c = a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resolve(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>优化写法应该如下，即<strong>用 Promise.resolve 快速构建一个 Promise 对象</strong>：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const b = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const c = a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Promise.resolve(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="异常处理">异常处理<a href="#异常处理" class="hash-link" aria-label="异常处理的直接链接" title="异常处理的直接链接">​</a></h3><p>前面 API 的介绍中已经有说明，尽量通过 catch() 去捕获 Promise 异常，需要说明的是，一旦被 catch 捕获过的异常，将不会再往外部传递，除非在 catch 中又触发了新的异常。</p><p>如下面代码，第一个异常被捕获后，就返回了一个新的 Promise，这个 Promise 对象没有异常，将会进入后面的 then() 逻辑：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const p = new Promise((resolve, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  reject(&#x27;异常啦&#x27;); // 或者通过 throw new Error() 跑出异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).catch((err) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;捕获异常啦&#x27;); // 进入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).catch(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;还有异常吗&#x27;); // 不进入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}).then(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;成功&#x27;); // 进入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果 catch 里面在处理异常时，又发生了新的异常，将会继续往外冒，这个时候我们不可能无止尽的在后面添加 catch 来捕获，所以 Promise <strong>有一个小的缺点就是最后一个 catch 的异常没办法捕获</strong>（当然实际出现异常的可能性很低，基本不造成什么影响）。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="使用-async-await">使用 async await<a href="#使用-async-await" class="hash-link" aria-label="使用 async await的直接链接" title="使用 async await的直接链接">​</a></h3><p>实际使用中，我们一般通过 async await 来配合 Promise 使用，这样可以让代码可读性更强，彻底没有&quot;回调&quot;的痕迹了。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const data = await axios.get(url);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 等效于</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return axios.get(url).then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对 async await 很多人都会用，但要注意几个非常重要的点。</p><ul><li><strong>await 同一行后面的内容对应 Promise 主体内容，即同步执行的</strong></li><li><strong>await 下一行的内容对应 then()里面的内容，是异步执行的</strong></li><li><strong>await 同一行后面应该跟着一个 Promise 对象，如果不是，需要转换（如果是常量会自动转换）</strong></li><li><strong>async 函数的返回值还是一个 Promise 对象</strong></li></ul><p>比如下面写法就是不正确的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // await 不认识后面的 setTimeout，不知道何时返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const data = await setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, 3000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;3 秒到了&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正确写法是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const data = await new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      resolve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 3000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;3 秒到了&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="promise-高级应用">Promise 高级应用<a href="#promise-高级应用" class="hash-link" aria-label="Promise 高级应用的直接链接" title="Promise 高级应用的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="提前预加载应用">提前预加载应用<a href="#提前预加载应用" class="hash-link" aria-label="提前预加载应用的直接链接" title="提前预加载应用的直接链接">​</a></h3><p>有这样一个场景：页面的数据量较大，通过缓存类将数据缓存在了本地，下一次可以直接使用缓存，在一定数据规模时，本地的缓存初始化和读取策略也会比较耗时。这个时候我们可以继续等待缓存类初始完成并读取本地数据，也可以不等待缓存类，而是直接提前去后台请求数据。两种方法最终谁先返回的时间不确定。那么为了让我们的数据第一时间准备好，让用户尽可能早地看到页面，我们可以通过 Promise 来做加载优化。</p><p>策略是页面加载后，立马调用 Promise 封装的后台请求，去后台请求数据。同时初始化缓存类并调用 Promise 封装的本地读取数据。最后在显示数据的时候，看谁先返回用谁的。</p><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicAcmRcibdxnTRBqbEVv6k2iaur7dhHyAFrHjlEfYF1ez0gic6UibTy0IzcXVicRIO2A1ial5DrjSmI1ibdg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="中断场景应用">中断场景应用<a href="#中断场景应用" class="hash-link" aria-label="中断场景应用的直接链接" title="中断场景应用的直接链接">​</a></h3><p>实际应用中，还有这样一种场景：我们正在发送多个请求用于请求数据，等待完成后将数据插入到不同的 dom 元素中，而如果在中途 dom 元素被销毁了（比如 react 在 useEffect 中请求的数据时，组件销毁），这时就可能会报错。因此我们需要提前中断正在请求的 Promise，不让其进入到 then 中执行回调。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">useEffect(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let dataPromise = new Promise(...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    let data = await dataPromise();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // TODO 接下来处理 data，此时本组件可能已经销毁了，dom 也不存在了，所以需要在下面对 Promise 进行中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // TODO 组件销毁时，对 dataPromise 进行中断或取消</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们可以对生成的 Promise 对象进行再一次包装，返回一个新的 Promise 对象，而新的对象上被我们增加了 cancel 方法，用于取消。这里的原理就是在 cancel 方法里面去阻止 Promise 对象执行 then()方法。</p><p>下面构造了一个 cancelPromise 用于和原始 Promise 竞速，最终返回合并后的 Promise，外层如果调用了 cancel 方法，cancelPromise 将提前结束，整个 Promise 结束。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function getPromiseWithCancel(originPromise) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let cancel = (v) =&gt; {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  let isCancel = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const cancelPromise = new Promise(function (resolve, reject) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cancel = e =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      isCancel = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      reject(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const groupPromise = Promise.race([originPromise, cancelPromise])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(e =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (isCancel) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 主动取消时，不触发外层的 catch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new Promise(() =&gt; {});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      return Promise.reject(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Object.assign(groupPromise, { cancel });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用如下</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const originPromise = axios.get(url);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promiseWithCancel = getPromiseWithCancel(originPromise);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">promiseWithCancel.then((data) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;渲染数据&#x27;, data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">promiseWithCancel.cancel(); // 取消 Promise，将不会再进入 then() 渲染数据</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="promise-深入理解之控制反转">Promise 深入理解之控制反转<a href="#promise-深入理解之控制反转" class="hash-link" aria-label="Promise 深入理解之控制反转的直接链接" title="Promise 深入理解之控制反转的直接链接">​</a></h2><p>熟悉了 Promise 的基本运用后，我们再来深入点理解。Promise 和 callback 还有个本质区别，就是<strong>控制权反转</strong>。</p><p>callback 模式下，回调函数是由<strong>业务层</strong>传递给<strong>封装层</strong>的，<strong>封装层</strong>在任务结束时执行了回调函数。</p><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicAcmRcibdxnTRBqbEVv6k2ialffaNicAMZJGxVda6dmfLocjpC6lneUUicIj35nPOk6T3JKELBvNPG8A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><p>而 Promise 模式下，<strong>业务层</strong>并没有把回调函数直接传递给<strong>封装层</strong>( Promise 对象内部)，<strong>封装层</strong>在任务结束时也不知道要做什么回调，只是通过 resolve 或 reject 来通知到  <strong>业务层</strong>，从而由<strong>业务层</strong>自己在 then() 或 reject() 里面去控制自己的回调执行。</p><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73zicAcmRcibdxnTRBqbEVv6k2ia1sGENib6R5DJ3ZYSAND75IiaIicDibkVegz2ic0AUSiaHSzSj2fW2uK5JjGg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><p>这里可能理解起来有点绕，换种等效的简单理解：我们知道函数一般是分<strong>定义</strong> + <strong>调用</strong>步骤的，先<strong>定义</strong>，后<strong>调用</strong>。谁<strong>调用</strong>了函数，就表示谁在<strong>控制</strong>这个函数的执行。</p><p>那么我们来看 callback 模式下，<strong>业务层</strong>将回调函数的<strong>定义</strong>传给了<strong>封装层</strong>，<strong>封装层</strong>在内部完成了回调函数的<strong>调用</strong>执行，<strong>业务层</strong>并没有调用回调函数，甚至业务层都看不到其调用代码，所以<strong>回调函数的执行控制权在封装层</strong>。</p><p>而 Promise 模式下，回调函数的调用执行是在 then() 里面完成的，是由<strong>业务层</strong>发起的，业务层不仅能看到回调函数的调用代码，也能修改，<strong>因此回调函数的控制权在业务层</strong>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="手动实现-promise-类的思路">手动实现 Promise 类的思路<a href="#手动实现-promise-类的思路" class="hash-link" aria-label="手动实现 Promise 类的思路的直接链接" title="手动实现 Promise 类的思路的直接链接">​</a></h2><p>现在我们已经熟悉了 Promise 的详细使用方式，假设让你回到 Promise 类出现之前，那时的 ES6 还没出现，你为了淘汰 callback 的回调写法，准备自己写一个 Promise 类，你会怎么做？</p><p>其实这就是常见面试手写 Promise 题目。我们只要抓住 Promise 的一些特点和关键点就能比较顺利实现。</p><p>首先 Promise 是一个类，构造函数接收参数是一个函数，而这个函数的参数是 resolve 和 reject 两个内部函数，也就是我们需要构建 resolve 和 reject 传给它，同时让它立即执行。另外咱这个类是有三种状态及 then 和 catch 等方法。根据这些就能快速先把类框架创建好。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class MyPromise () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  constructor (fun) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.status = &#x27;pending&#x27;; // pending、fulfilled、rejected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fun(this.resolve, this.reject); // 立即执行主体函数，参数函数可能需要 bind(this)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  resolve() {} // 定义 resolve，内容待定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  reject() {} // 定义 reject，内容待定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  then() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  catch() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有了雏形之后，再根据对 Promise 的理解逐步完善即可，如 resolve 和 reject 里面我们肯定是要去修改 status 状态的； 而 then() 里面我们需要接收并保存传进来的回调等等。 完整案例可在网上搜索，重点是理解它的实现思路。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="总结的直接链接" title="总结的直接链接">​</a></h2><p>今天我们对 Promise 进行了基本 API 介绍，然后重点对其实际应用进行了介绍和解析。相信通过本文的学习，可以提升你对 Promise 的理解和运用能力。</p><p>同时文中的一些实际场景举例是非常典型的应用场景，比如 async await 和手写 Promise 是很容易被考察的点。并且考察方式变化很多，万变不离其宗，抓住文中重点内容，做到举一反三不是问题。</p><p>最后可以看一个有点难度的 Promise 执行顺序分析题目：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function promise2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;promise2 start&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resolve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function promise3() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;promise3 start&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resolve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function promise4() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((resolve) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;promise4 start&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    resolve();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }).then(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&#x27;promise4 end&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async function asyncFun() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;async1 start&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  await promise2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;async1 inner&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  await promise3();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;async1 end&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;setTimeout start&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  promise1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&#x27;setTimeout end&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">asyncFun();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">promise4();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(&#x27;script end&#x27;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/hijulien/frontend/JavaScript/WebAPI"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">WebAPI</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/hijulien/frontend/JavaScript/Error"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Error</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#promise-含义及基本介绍" class="table-of-contents__link toc-highlight">Promise 含义及基本介绍</a><ul><li><a href="#基本用法" class="table-of-contents__link toc-highlight">基本用法</a></li><li><a href="#promise-异常处理" class="table-of-contents__link toc-highlight">Promise 异常处理</a></li><li><a href="#链式调用" class="table-of-contents__link toc-highlight">链式调用</a></li><li><a href="#常用-api" class="table-of-contents__link toc-highlight">常用 API</a></li></ul></li><li><a href="#promise-最佳实践介绍" class="table-of-contents__link toc-highlight">Promise 最佳实践介绍</a><ul><li><a href="#异步-promise-化的两个关键" class="table-of-contents__link toc-highlight">异步 Promise 化的两个关键</a></li><li><a href="#如何避免冗余封装" class="table-of-contents__link toc-highlight">如何避免冗余封装？</a></li><li><a href="#异常处理" class="table-of-contents__link toc-highlight">异常处理</a></li><li><a href="#使用-async-await" class="table-of-contents__link toc-highlight">使用 async await</a></li></ul></li><li><a href="#promise-高级应用" class="table-of-contents__link toc-highlight">Promise 高级应用</a><ul><li><a href="#提前预加载应用" class="table-of-contents__link toc-highlight">提前预加载应用</a></li><li><a href="#中断场景应用" class="table-of-contents__link toc-highlight">中断场景应用</a></li></ul></li><li><a href="#promise-深入理解之控制反转" class="table-of-contents__link toc-highlight">Promise 深入理解之控制反转</a></li><li><a href="#手动实现-promise-类的思路" class="table-of-contents__link toc-highlight">手动实现 Promise 类的思路</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright @ 2023 The way to becoming a god.</div></div></div></footer></div>
<script src="/hijulien/assets/js/runtime~main.223637bc.js"></script>
<script src="/hijulien/assets/js/main.44331553.js"></script>
</body>
</html>