<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-frontend docs-doc-id-JavaScript/Error">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Error | note</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://hijulien.github.io/hijulien/frontend/JavaScript/Error"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-frontend-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-frontend-current"><meta data-rh="true" property="og:title" content="Error | note"><meta data-rh="true" name="description" content="1. 错误概述"><meta data-rh="true" property="og:description" content="1. 错误概述"><link data-rh="true" rel="icon" href="/hijulien/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://hijulien.github.io/hijulien/frontend/JavaScript/Error"><link data-rh="true" rel="alternate" href="https://hijulien.github.io/hijulien/frontend/JavaScript/Error" hreflang="zh"><link data-rh="true" rel="alternate" href="https://hijulien.github.io/hijulien/frontend/JavaScript/Error" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/hijulien/blog/rss.xml" title="note RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/hijulien/blog/atom.xml" title="note Atom Feed"><link rel="stylesheet" href="/hijulien/assets/css/styles.d03fc8fd.css">
<link rel="preload" href="/hijulien/assets/js/runtime~main.ab63e8e5.js" as="script">
<link rel="preload" href="/hijulien/assets/js/main.c15d0a97.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/hijulien/"><div class="navbar__logo"><img src="/hijulien/img/julien.jpg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/hijulien/img/julien.jpg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Hi Julien</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/hijulien/frontend/JavaScript">frontend</a><a class="navbar__item navbar__link" href="/hijulien/backend/Linux">backend</a><a class="navbar__item navbar__link" href="/hijulien/others/Git">others</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" path="docs/something" href="/hijulien/docs/第 1 章 内存与数据结构">小专栏</a><a href="https://github.com/hijulien/notes" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/hijulien/frontend/JavaScript/">JavaScript</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/">Grammar</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/API">API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/Fragment">Fragment</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/WebAPI">WebAPI</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hijulien/frontend/JavaScript/Promise">Promise</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/hijulien/frontend/JavaScript/Error">Error</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/ES6/intro">ES6</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/TypeScript/intro">TypeScript</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/React/">React</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/WebAPI/canvas">webAPI</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/hijulien/frontend/Axios/">Axios</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/hijulien/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">JavaScript</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Error</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Error</h1></header><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-错误概述">1. 错误概述<a href="#1-错误概述" class="hash-link" aria-label="1. 错误概述的直接链接" title="1. 错误概述的直接链接">​</a></h2><p>JavaScript 中的错误是一个对象，在发生错误时会抛出该对象以停止程序。在 JavaScript 中，可以通过构造函数来创建一个新的通用错误：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const err = new Error(&quot;Error&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当然，也可以省略 new 关键字：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const err = Error(&quot;Error&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Error 对象有三个属性：</p><ul><li><code>message</code>：带有错误消息的字符串；</li><li><code>name</code>: 错误的类型；</li><li><code>stack</code>：函数执行的堆栈跟踪。</li></ul><p>例如，创建一个 TypeError 对象，该消息将携带实际的错误字符串，其 name 将是“TypeError”：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const wrongType = TypeError(&quot;Expected number&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">wrongType.message; // &#x27;Expected number&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">wrongType.name;    // &#x27;TypeError&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>堆栈跟踪是发生异常或警告等事件时程序所处的方法调用列表：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWgvEAJNTDHZnRzTs1oQbXibpo3cLCCTqm20K9rolPldibD3IraFFibMxaQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">它首先会打印错误名称和消息，然后是被调用的方法列表。每个方法调用都说明其源代码的位置和调用它的行。可以使用此数据来浏览代码库并确定导致错误的代码段。此方法列表以堆叠的方式排列。它显示了异常首先被抛出的位置以及它如何通过堆栈方法调用传播。为异常实施捕获不会让它通过堆栈向上传播并使程序崩溃。</p><p>对于 Error 对象，Firefox 还实现了一些非标准属性：</p><ul><li><code>columnNumber</code>：错误所在行的列号；</li><li><code>filename</code>：发生错误的文件</li><li><code>lineNumber</code>：发生错误的行号</li></ul><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWD78ERK9ElMVqrC2WDywfblOHyDFuq65oMAKvhibB6PlPZghDe9dPGiag/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-错误类型">2. 错误类型<a href="#2-错误类型" class="hash-link" aria-label="2. 错误类型的直接链接" title="2. 错误类型的直接链接">​</a></h2><p>JavaScript 中有一系列预定义的错误类型。只要使用者没有明确处理应用程序中的错误，它们就会由 JavaScript 运行时自动选择和定义。</p><p>JavaScript中的错误类型包括：</p><ul><li>EvalError</li><li>InternalError</li><li>RangeError</li><li>ReferenceError</li><li>SyntaxError</li><li>TypeError</li><li>URIError</li></ul><p>这些错误类型都是实际的构造函数，旨在返回一个新的错误对象。最常见的就是 TypeError。大多数时候，大部分错误将直接来自 JavaScript 引擎，例如 InternalError 或 SyntaxError。</p><p>JavaScript 提供了 <code>instanceof</code> 运算符可以用于区分异常类型：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  If (typeof x !== ‘number’) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       throw new TypeError(‘x 应是数字’);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else if (x &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       throw new RangeError(&#x27;x 应大于 0&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (err) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (err instanceof TypeError) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 处理 TypeError 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (err instanceof RangeError) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 处理 RangeError 错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 处理其他类型错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面来了解 JavaScript 中最常见的错误类型，并了解它们发生的时间和原因。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1syntaxerror">（1）SyntaxError<a href="#1syntaxerror" class="hash-link" aria-label="（1）SyntaxError的直接链接" title="（1）SyntaxError的直接链接">​</a></h3><p>SyntaxError 表示语法错误。这些错误是最容易修复的错误之一，因为它们表明代码语法中存在错误。由于 JavaScript 是一种解释而非编译的脚本语言，因此当应用程序执行包含错误的脚本时会抛出这些错误。在编译语言的情况下，此类错误在编译期间被识别。因此，在修复这些问题之前，不会创建应用程序二进制文件。</p><p>SyntaxError 发生的一些常见原因是：</p><ul><li>缺少引号</li><li>缺少右括号</li><li>大括号或其他字符对齐不当</li></ul><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWUFdYj57d6kEkXfmwjzKm63KYzbElYfIPv3VRtmODy8PsMIPTNJYAPw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2typeerror">（2）TypeError<a href="#2typeerror" class="hash-link" aria-label="（2）TypeError的直接链接" title="（2）TypeError的直接链接">​</a></h3><p>TypeError 是 JavaScript 应用程序中最常见的错误之一，当某些值不是特定的预期类型时，就会产生此错误。<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWjOSEZo7fPO4a2QLibvUREzoKt88q9wv8qKYGMtzGsj1ZvlAkBoMPlxw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">TypeError 发生的一些常见原因是：</p><ul><li>调用不是方法的对象。</li><li>试图访问 null 或未定义对象的属性</li><li>将字符串视为数字，反之亦然</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3referenceerror">（3）ReferenceError<a href="#3referenceerror" class="hash-link" aria-label="（3）ReferenceError的直接链接" title="（3）ReferenceError的直接链接">​</a></h3><p>ReferenceError 表示引用错误。当代码中的变量引用有问题时，会发生 ReferenceError。可能忘记在使用变量之前为其定义一个值，或者可能试图在代码中使用一个不可访问的变量。在任何情况下，通过堆栈跟踪都可以提供充足的信息来查找和修复有问题的变量引用。</p><p>ReferenceErrors 发生的一些常见原因如下：</p><ul><li>在变量名中输入错误。</li><li>试图访问其作用域之外的块作用域变量。</li><li>在加载之前从外部库引用全局变量。</li></ul><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWcVSia0D1HO5LoctW6RICjrFPvP1QQibfvl647opkxCCLoF9teB8fiaSsQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4rangeerror">（4）RangeError<a href="#4rangeerror" class="hash-link" aria-label="（4）RangeError的直接链接" title="（4）RangeError的直接链接">​</a></h3><p>RangeError 表示范围错误。当变量设置的值超出其合法值范围时，将抛出 RangeError。它通常发生在将值作为参数传递给函数时，并且给定值不在函数参数的范围内。当使用记录不完整的第三方库时，有时修复起来会很棘手，因为需要知道参数的可能值范围才能传递正确的值。</p><p>RangeError 发生的一些常见场景如下：</p><ul><li>试图通过 Array 构造函数创建非法长度的数组。</li><li>将错误的值传递给数字方法，例如 <code>toExponential()</code>、<code>toPrecision()</code>、<code>toFixed()</code> 等。</li><li>将非法值传递给字符串函数，例如 <code>normalize()</code>。</li></ul><p><img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWCicXL3icNY4Eot2br7eQDcNL7DGE0FYySkUDO41hm3ZVmgL8tDPE34Qg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5urierror">（5）URIError<a href="#5urierror" class="hash-link" aria-label="（5）URIError的直接链接" title="（5）URIError的直接链接">​</a></h3><p>URIError 表示 URI错误。当 URI 的编码和解码出现问题时，会抛出 URIError。JavaScript 中的 URI 操作函数包括：<code>decodeURI</code>、<code>decodeURIComponent</code> 等。如果使用了错误的参数（无效字符），就会抛出 URIError。<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWmqWgxACwqYwvLXQOicVcKlMJsyhJia7mDfVcdhMYK3DBw21Mul1BCozQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6evalerror">（6）EvalError<a href="#6evalerror" class="hash-link" aria-label="（6）EvalError的直接链接" title="（6）EvalError的直接链接">​</a></h3><p>EvalError 表示 Eval 错误。当 <code>eval()</code> 函数调用发生错误时，会抛出 EvalError。不过，当前的 JavaScript 引擎或 ECMAScript 规范不再抛出此错误。但是，为了向后兼容，它仍然是存在的。</p><p>如果使用的是旧版本的 JavaScript，可能会遇到此错误。在任何情况下，最好调查在eval()函数调用中执行的代码是否有任何异常。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7internalerror">（7）InternalError<a href="#7internalerror" class="hash-link" aria-label="（7）InternalError的直接链接" title="（7）InternalError的直接链接">​</a></h3><p>InternalError 表示内部错误。在 JavaScript 运行时引擎发生异常时使用。它表示代码可能存在问题也可能不存在问题。</p><p>InternalError 通常只发生在两种情况下：</p><ul><li>当 JavaScript 运行时的补丁或更新带有引发异常的错误时（这种情况很少发生）；</li><li>当代码包含对于 JavaScript 引擎而言太大的实体时（例如，数组初始值设定项太大、递归太多）。</li></ul><p>解决此错误最合适的方法就是通过错误消息确定原因，并在可能的情况下重构应用逻辑，以消除 JavaScript 引擎上工作负载的突然激增。</p><p><strong>注意：</strong> 现代 JavaScript 中不会抛出 EvalError 和 InternalError。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="8创建自定义错误类型">（8）创建自定义错误类型<a href="#8创建自定义错误类型" class="hash-link" aria-label="（8）创建自定义错误类型的直接链接" title="（8）创建自定义错误类型的直接链接">​</a></h3><p>虽然 JavaScript 提供了足够的错误类型类列表来涵盖大多数情况，但如果这些错误类型不能满足要求，还可以创建新的错误类型。这种灵活性的基础在于 JavaScript 允许使用 throw 命令抛出任何内容。</p><p>可以通过扩展 Error 类以创建自定义错误类：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class ValidationError extends Error {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    constructor(message) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = &quot;ValidationError&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以通过以下方式使用它：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">throw ValidationError(&quot;未找到该属性: name&quot;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以使用 <code>instanceof</code> 关键字识别它：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    validateForm() // 抛出 ValidationError 的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (e instanceof ValidationError) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-抛出错误">3. 抛出错误<a href="#3-抛出错误" class="hash-link" aria-label="3. 抛出错误的直接链接" title="3. 抛出错误的直接链接">​</a></h2><p>很多人认为错误和异常是一回事。实际上，<strong>Error 对象只有在被抛出时才会成为异常</strong>。</p><p>在 JavaScript 中抛出异常，可以使用 throw 来抛出 Error 对象：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">throw TypeError(&quot;Expected number&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>或者：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">throw new TypeError(&quot;Expected number&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>来看一个简单的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected string&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这里，我们检查函数参数是否为字符串。如果不是，就抛出异常。</p><p>从技术上讲，我们可以在 JavaScript 中抛出任何东西，而不仅仅是 Error 对象：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">throw Symbol();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">throw 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">throw &quot;Error!&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">throw null;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是，最好避免这样做：<strong>要抛出正确的 Error 对象，而不是原语</strong>。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-抛出异常时会发生什么">4. 抛出异常时会发生什么？<a href="#4-抛出异常时会发生什么" class="hash-link" aria-label="4. 抛出异常时会发生什么？的直接链接" title="4. 抛出异常时会发生什么？的直接链接">​</a></h2><p>异常一旦抛出，就会在程序堆栈中冒泡，除非在某个地方被捕获。</p><p>来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected string&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">toUppercase(4);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在浏览器或 Node.js 中运行此代码，程序将停止并抛出错误：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWicw0wiaibv2CG8BuTl3A3ibYGtbDKljnYPoicmnXBIyLgYYU5EZU9pRtlYw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">这里还显示了发生错误的确切行。这个错误就是一个<strong>堆栈跟踪</strong>，有助于跟踪代码中的问题。堆栈跟踪从下到上：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">at toUppercase (&lt;anonymous&gt;:3:11)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">at &lt;anonymous&gt;:9:1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>toUppercase 函数在第 9 行调用，在第 3 行抛出错误。除了在浏览器的控制台中查看此堆栈跟踪之外，还可以在 Error 对象的 <code>stack</code> 属性上访问它。</p><p>介绍完这些关于错误的基础知识之后，下面来看看同步和异步 JavaScript 代码中的错误和异常处理。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-同步错误处理">5. 同步错误处理<a href="#5-同步错误处理" class="hash-link" aria-label="5. 同步错误处理的直接链接" title="5. 同步错误处理的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1常规函数的错误处理">（1）常规函数的错误处理<a href="#1常规函数的错误处理" class="hash-link" aria-label="（1）常规函数的错误处理的直接链接" title="（1）常规函数的错误处理的直接链接">​</a></h3><p>同步代码会按照代码编写顺序执行。让我们再看看前面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected string&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">toUppercase(4);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这里，引擎调用并执行 toUppercase，这一切都是同步发生的。 要捕获由此类同步函数引发的异常，可以使用 try/catch/finally：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  toUppercase(4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通常，try 会处理正常的路径，或者可能进行的函数调用。catch 就会捕获实际的异常，它接收 Error 对象。而不管函数的结果如何，finally 语句都会运行：无论它失败还是成功，finally 中的代码都会运行。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2生成器函数的错误处理">（2）生成器函数的错误处理<a href="#2生成器函数的错误处理" class="hash-link" aria-label="（2）生成器函数的错误处理的直接链接" title="（2）生成器函数的错误处理的直接链接">​</a></h3><p>JavaScript 中的生成器函数是一种特殊类型的函数。它可以随意暂停和恢复，除了在其内部范围和消费者之间提供双向通信通道。为了创建一个生成器函数，需要在 function 关键字后面加上一个 <code>*</code>：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>只要进入函数，就可以使用 yield 来返回值：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>生成器函数的返回值是一个迭代器对象。要从生成器中提取值，可以使用两种方法：</p><ul><li>在迭代器对象上调用 <code>next()</code></li><li>使用 <code>for...of</code> 进行迭代</li></ul><p>以上面的代码为例，要从生成器中获取值，可以这样做：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const go = generate();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当我们调用生成器函数时，这里的 go 就是生成的迭代器对象。接下来，就可以调用 go.next() 来继续执行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const go = generate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const firstStep = go.next().value; // 33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const secondStep = go.next().value; // 99</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>生成器也可以接受来自调用者的值和异常。除了 next()，从生成器返回的迭代器对象还有一个 throw() 方法。使用这种方法，就可以通过向生成器中注入异常来停止程序：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const go = generate();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const firstStep = go.next().value; // 33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.throw(Error(&quot;Tired of iterating!&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const secondStep = go.next().value; // never reached</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>要捕获此类错误，可以使用 try/catch 将代码包装在生成器中：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>生成器函数也可以向外部抛出异常。 捕获这些异常的机制与捕获同步异常的机制相同：try/catch/finally。</p><p>下面是使用 for...of 从外部使用的生成器函数的示例：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function* generate() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  throw Error(&quot;Tired of iterating!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (const value of generate()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWKL2iaHzslIuiaKZsqq7RUakMht6rX9zRhreeMnZl3tQWuRPHf61W9PAA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">这里，try 块中包含正常的迭代。如果发生任何异常，就会用 catch 捕获它。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-异步错误处理">6. 异步错误处理<a href="#6-异步错误处理" class="hash-link" aria-label="6. 异步错误处理的直接链接" title="6. 异步错误处理的直接链接">​</a></h2><p>浏览器中的异步包括定时器、事件、Promise 等。异步世界中的错误处理与同步世界中的处理不同。下面来看一些例子。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1定时器的错误处理">（1）定时器的错误处理<a href="#1定时器的错误处理" class="hash-link" aria-label="（1）定时器的错误处理的直接链接" title="（1）定时器的错误处理的直接链接">​</a></h3><p>上面我们介绍了如何使用 try/catch/finally 来处理错误，那异步中可以使用这些来处理错误吗？先来看一个例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function failAfterOneSecond() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw Error(&quot;Wrong!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此函数在大约 1 秒后会抛出错误。那处理此异常的正确方法是什么？以下代码是无效的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function failAfterOneSecond() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw Error(&quot;Wrong!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  failAfterOneSecond();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们知道，try/catch是同步的，所以没办法这样来处理异步中的错误。当传递给 setTimeout的回调运行时，try/catch 早已执行完毕。程序将会崩溃，因为未能捕获异常。它们是在两条路径上执行的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">A: --&gt; try/catch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">B: --&gt; setTimeout --&gt; callback --&gt; throw</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2事件的错误处理">（2）事件的错误处理<a href="#2事件的错误处理" class="hash-link" aria-label="（2）事件的错误处理的直接链接" title="（2）事件的错误处理的直接链接">​</a></h3><p>我们可以监听页面中任何 HTML 元素的事件，DOM 事件的错误处理机制遵循与任何异步 Web API 相同的方案。</p><p>来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const button = document.querySelector(&quot;button&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">button.addEventListener(&quot;click&quot;, function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  throw Error(&quot;error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里，在单击按钮后立即抛出了异常，我们该如何捕获这个异常呢？这样写是不起作用的，也不会阻止程序崩溃：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const button = document.querySelector(&quot;button&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  button.addEventListener(&quot;click&quot;, function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw Error(&quot;error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与前面的 setTimeout 例子一样，任何传递给 addEventListener 的回调都是异步执行的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Track A: --&gt; try/catch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Track B: --&gt; addEventListener --&gt; callback --&gt; throw</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果不想让程序崩溃，为了正确处理错误，就必须将 try/catch 放到 addEventListener 的回调中。不过这样做并不是最佳的处理方式，与 setTimeout 一样，异步代码路径抛出的异常无法从外部捕获，并且会使程序崩溃。</p><p>下面会介绍 Promises 和 async/await 是如何简化异步代码的错误处理的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3onerror">（3）onerror<a href="#3onerror" class="hash-link" aria-label="（3）onerror的直接链接" title="（3）onerror的直接链接">​</a></h3><p>HTML 元素有许多事件处理程序，例如 <code>onclick</code>、<code>onmouseenter</code>、<code>onchange</code> 等。除此之外，还有 <code>onerror</code>，每当 <code>&lt;img&gt;</code> 标签或 <code>&lt;script&gt;</code> 等 HTML 元素命中不存在的资源时，onerror 事件处理程序就会触发。</p><p>来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;body&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  &lt;img src=&quot;nowhere-to-be-found.png&quot;&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/body&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当访问的资源缺失时，浏览器的控制台就会报错：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">GET http://localhost:5000/nowhere-to-be-found.png</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[HTTP/1.1 404 Not Found 3ms]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 JavaScript 中，可以使用适当的事件处理程序“捕获”此错误：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const image = document.querySelector(&quot;img&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">image.onerror = function(event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>或者使用 addEventListener 来监听 error 事件，当发生错误时进行处理：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const image = document.querySelector(&quot;img&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">image.addEventListener(&quot;error&quot;, function(event) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(event);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此模式对于加载备用资源以代替丢失的图像或脚本很有用。不过需要记住：onerror 与 throw 或 try/catch 是无关的。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4promise-的错误处理">（4）Promise 的错误处理<a href="#4promise-的错误处理" class="hash-link" aria-label="（4）Promise 的错误处理的直接链接" title="（4）Promise 的错误处理的直接链接">​</a></h3><p>下面来通过最上面的 toUppercase 例子看看 Promise 是如何处理错误的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected string&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">toUppercase(4);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对上面的代码进行修改，不返回简单的字符串或异常，而是分别使用 <code>Promise.reject</code> 和 <code>Promise.resolve</code> 来处理错误和成功：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Promise.reject(TypeError(&quot;Expected string&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  const result = string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return Promise.resolve(result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从技术上讲，这段代码中没有任何异步的内容，但它可以很好地说明 Promise 的错误处理机制。</p><p>现在我们就可以在 then 中使用结果，并使用 catch 来处理被拒绝的 Promise：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">toUppercase(99)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(result =&gt; result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.message));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWhQoCMCZUPvPHks9HEfOicN9TuZBeJ0yh8cLqk4sBDxbbUOx0o2ZsDMg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">在 Promise 中，catch 是用来处理错误的。除了 catch 还有 finally，类似于 try/catch 中的finally。不管 Promise 结果如何，finally 都会执行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">toUppercase(99)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(result =&gt; result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.message))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .finally(() =&gt; console.log(&quot;Finally&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWS0hEDWzgeYDUGf4G3jFx8mA7MypaCc8CZRicFjIlYicoIvRE5GWcklQQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">需要记住，任何传递给 then/catch/finally 的回调都是由微任务队列异步处理的。 它们是微任务，优先于事件和计时器等宏任务。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5promise-error-throw">（5）Promise, error, throw<a href="#5promise-error-throw" class="hash-link" aria-label="（5）Promise, error, throw的直接链接" title="（5）Promise, error, throw的直接链接">​</a></h3><p>作为拒绝 Promise 时的最佳实践，可以传入 error 对象：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Promise.reject(TypeError(&quot;Expected string&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样，在整个代码库中保持错误处理的一致性。 其他团队成员总是可以访问 error.message，更重要的是可以检查堆栈跟踪。</p><p>除了 <code>Promise.rejec</code>t 之外，还可以通过抛出异常来退出 Promise 执行链。来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Promise.resolve(&quot;A string&quot;).then(value =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof value === &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected number!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里使用 字符串来 resolve 一个 Promise，然后执行链立即使用 throw 断开。为了停止异常的传播，可以使用 catch 来捕获错误：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Promise.resolve(&quot;A string&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(value =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (typeof value === &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw TypeError(&quot;Expected number!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(reason =&gt; console.log(reason.message));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这种模式在 fetch 中很常见，可以通过检查 response 对象来查找错误：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fetch(&quot;https://example-dev/api/&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(response =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!response.ok) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw Error(response.statusText);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return response.json();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(json =&gt; console.log(json));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里的异常可以使用 catch 来拦截。 如果失败了，并且没有拦截它，异常就会在堆栈中向上冒泡。这本身并没有什么问题，但不同的环境对未捕获的拒绝有不同的反应。</p><p>例如，Node.js 会让任何未处理 Promise 拒绝的程序崩溃：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所以，最好去捕获错误。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6使用-promise-处理定时器错误">（6）使用 Promise 处理定时器错误<a href="#6使用-promise-处理定时器错误" class="hash-link" aria-label="（6）使用 Promise 处理定时器错误的直接链接" title="（6）使用 Promise 处理定时器错误的直接链接">​</a></h3><p>对于计时器或事件，不能捕获回调抛出的异常。上面有一个例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function failAfterOneSecond() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw Error(&quot;Error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }, 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 不生效</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  failAfterOneSecond();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们可以使用 Promise 来包装计时器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function failAfterOneSecond() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return new Promise((_, reject) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      reject(Error(&quot;Error&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里通过 reject 捕获了一个 Promise 拒绝，它带有一个 error 对象。此时就可以用 catch 来处理异常了：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">failAfterOneSecond().catch(reason =&gt; console.error(reason.message));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里使用 value 作为 Promise 的返回值，使用 reason 作为拒绝的返回对象。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7promiseall-的错误处理">（7）Promise.all 的错误处理<a href="#7promiseall-的错误处理" class="hash-link" aria-label="（7）Promise.all 的错误处理的直接链接" title="（7）Promise.all 的错误处理的直接链接">​</a></h3><p>Promise.all 方法接受一个 Promise 数组，并返回所有解析 Promise 的结果数组：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.resolve(&quot;one&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.resolve(&quot;two&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.all([promise1, promise2]).then((results) =&gt; console.log(results));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结果： [&#x27;one&#x27;, &#x27;two&#x27;]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果这些 Promise 中的任何一个被拒绝，Promise.all 将拒绝并返回第一个被拒绝的 Promise 的错误。</p><p>为了在 Promise.all 中处理这些情况，可以使用 catch：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.resolve(&quot;good&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.reject(Error(&quot;Bad&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise3 = Promise.reject(Error(&quot;Bad+&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.all([promise1, promise2, promise3])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(results =&gt; console.log(results))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.message));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果想要运行一个函数而不考虑 Promise.all 的结果，可以使用 finally：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Promise.all([promise1, promise2, promise3])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(results =&gt; console.log(results))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.message))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .finally(() =&gt; console.log(&quot;Finally&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="8promiseany-的错误处理">（8）Promise.any 的错误处理<a href="#8promiseany-的错误处理" class="hash-link" aria-label="（8）Promise.any 的错误处理的直接链接" title="（8）Promise.any 的错误处理的直接链接">​</a></h3><p>Promise.any 和 Promise.all 恰恰相反。Promise.all 如果某一个失败，就会抛出第一个失败的错误。而 Promise.any 总是返回第一个成功的 Promise，无论是否发生任何拒绝。</p><p>相反，如果传递给 Promise.any 的所有 Promise 都被拒绝，那产生的错误就是 AggregateError。 来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.reject(Error(&quot;Error&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.reject(Error(&quot;Error+&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.any([promise1, promise2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(result =&gt; console.log(result))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .finally(() =&gt; console.log(&quot;Finally&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWcko6z0sIZqeh1uyGOibFPYnCKrxHQ6fzicabOBmRbojr9FBzZUibNicmQA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">这里用 catch 处理错误。AggregateError 对象具有与基本错误相同的属性，外加一个 errors 属性：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.reject(Error(&quot;Error&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.reject(Error(&quot;Error+&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.any([promise1, promise2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(result =&gt; console.log(result))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.errors))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .finally(() =&gt; console.log(&quot;Finally&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此属性是一个包含所有被拒绝的错误信息的数组：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWiarlIlODA5P6zIDiaTWo1lib7O2ClzDp6aX4N7N661FvADtch4YE4JLzQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="9promiserace-的错误处理">（9）Promise.race 的错误处理<a href="#9promiserace-的错误处理" class="hash-link" aria-label="（9）Promise.race 的错误处理的直接链接" title="（9）Promise.race 的错误处理的直接链接">​</a></h3><p>Promise.race 接受一个 Promise 数组，并返回第一个成功的 Promise 的结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.resolve(&quot;one&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.resolve(&quot;two&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.race([promise1, promise2]).then(result =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结果：one</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那如果有被拒绝的 Promise，但它不是传入数组中的第一个呢：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.resolve(&quot;one&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const rejection = Promise.reject(Error(&quot;Bad&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.resolve(&quot;two&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.race([promise1, rejection, promise2]).then(result =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(result)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 结果：one</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样结果还是 one，不会影响正常的执行。</p><p>如果被拒绝的 Promise 是数组的第一个元素，则 Promise.race 拒绝，就必须要必须捕获拒绝：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.resolve(&quot;one&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const rejection = Promise.reject(Error(&quot;Bad&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.resolve(&quot;two&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.race([rejection, promise1, promise2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(result =&gt; console.log(result))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.message));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// Bad</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="10promiseallsettled-的错误处理">（10）Promise.allSettled 的错误处理<a href="#10promiseallsettled-的错误处理" class="hash-link" aria-label="（10）Promise.allSettled 的错误处理的直接链接" title="（10）Promise.allSettled 的错误处理的直接链接">​</a></h3><p>Promise.allSettled 是 ECMAScript 2020 新增的 API。它和 Promise.all 类似，不过不会被短路，也就是说当Promise全部处理完成后，可以拿到每个 Promise 的状态, 而不管其是否处理成功。</p><p>来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promise1 = Promise.resolve(&quot;Good!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const promise2 = Promise.reject(Error(&quot;Bad!&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Promise.allSettled([promise1, promise2])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(results =&gt; console.log(results))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .finally(() =&gt; console.log(&quot;Finally&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里向 Promise.allSettled 传递了一个包含两个 Promise 的数组：一个已解决，另一个已拒绝。</p><p>输出结果如下：</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="11asyncawait-的错误处理">（11）async/await 的错误处理<a href="#11asyncawait-的错误处理" class="hash-link" aria-label="（11）async/await 的错误处理的直接链接" title="（11）async/await 的错误处理的直接链接">​</a></h3><p>JavaScript 中的 async/await 表示异步函数，用同步的方式去编写异步，可读性更好。</p><p>下面来改编上面的同步函数 toUppercase，通过将 async 放在 function 关键字之前将其转换为异步函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected string&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>只需在 function 前加上 async 前缀，就可以让函数返回一个 Promise。这意味着我们可以在函数调用之后链式调用 then、catch 和 finally：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">toUppercase(&quot;hello&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .then(result =&gt; console.log(result))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .catch(error =&gt; console.error(error.message))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  .finally(() =&gt; console.log(&quot;Always runs!&quot;));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当从 async 函数中抛出异常时，异常会成为底层 Promise 被拒绝的原因。任何错误都可以从外部用 catch 拦截。</p><p>除此之外，还可以使用 try/catch/finally 来处理错误，就像在同步函数中一样。</p><p>例如，从另一个函数 consumer 中调用 toUppercase，它方便地用 try/catch/finally 包装了函数调用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function toUppercase(string) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  if (typeof string !== &quot;string&quot;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw TypeError(&quot;Expected string&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  return string.toUpperCase();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async function consumer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    await toUppercase(98);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;Finally&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWHWbianRibsYzALASvHicUXUkrlZ3kMeG5JHhJ7nEUc7b4fr2pm23bXPFA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="12异步生成器的错误处理">（12）异步生成器的错误处理<a href="#12异步生成器的错误处理" class="hash-link" aria-label="（12）异步生成器的错误处理的直接链接" title="（12）异步生成器的错误处理的直接链接">​</a></h3><p>JavaScript 中的异步生成器是能够生成 Promise 而不是简单值的生成器函数。它将生成器函数与异步相结合，结果是一个生成器函数，其迭代器对象向消费者公开一个 Promise。</p><p>要创建一个异步生成器，需要声明一个带有星号 * 的生成器函数，前缀为 async：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function* asyncGenerator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  throw Error(&quot;Bad!&quot;); // Promise.reject</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为异步生成器是基于 Promise，所以同样适用 Promise 的错误处理规则，在异步生成器中，throw 会导致 Promise 拒绝，可以用 catch 拦截它。</p><p>要想从异步生成器处理 Promise，可以使用 then：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const go = asyncGenerator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().catch(reason =&gt; console.error(reason.message));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWicLbibMicicx7luQd1zAJObuaicIcA82KPZdcWxoib47904Zkf6HZzuo6CsQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">也使用异步迭代 for await...of。 要使用异步迭代，需要用 async 函数包装 consumer：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function* asyncGenerator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  throw Error(&quot;Bad&quot;); // Promise.reject</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async function consumer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for await (const value of asyncGenerator()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与 async/await 一样，可以使用 try/catch 来处理任何异常：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function* asyncGenerator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  throw Error(&quot;Bad&quot;); // Promise.reject</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">async function consumer() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for await (const value of asyncGenerator()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      console.log(value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">consumer();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyW1dVphMKsbiao6CNdsE2nY41qpicctBZyFYx97Kwy4QpSCticJAyovJzCA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">从异步生成器函数返回的迭代器对象也有一个 <code>throw()</code> 方法。在这里对迭代器对象调用 throw() 不会抛出异常，而是 Promise 拒绝：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function* asyncGenerator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  yield 11;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const go = asyncGenerator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.throw(Error(&quot;Reject!&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value)); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：<img loading="lazy" src="https://mmbiz.qpic.cn/mmbiz_png/EO58xpw5UMMNJibrHzI61FGON7Cwq9nyWOicwy49sq6nCFLicLePF0MY3hEm5tS9t6ncejyytiazUQRvGPnJrfcY8Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" class="img_ev3q">可以通过以下方式来捕获错误：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">go.throw(Error(&quot;Let&#x27;s reject!&quot;)).catch(reason =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(reason.message)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们知道，迭代器对象的 throw() 是在生成器内部发送异常的。所以还可以使用以下方式来处理错误：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">async function* asyncGenerator() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield 33;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield 99;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    yield 11;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  } catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const go = asyncGenerator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.throw(Error(&quot;Reject!&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">go.next().then(value =&gt; console.log(value));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-nodejs-错误处理">5. Node.js 错误处理<a href="#5-nodejs-错误处理" class="hash-link" aria-label="5. Node.js 错误处理的直接链接" title="5. Node.js 错误处理的直接链接">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1同步错误处理">（1）同步错误处理<a href="#1同步错误处理" class="hash-link" aria-label="（1）同步错误处理的直接链接" title="（1）同步错误处理的直接链接">​</a></h3><p>Node.js 中的同步错误处理与 JavaScript 是一样的，可以使用 try/catch/finally。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2异步错误处理回调模式">（2）异步错误处理：回调模式<a href="#2异步错误处理回调模式" class="hash-link" aria-label="（2）异步错误处理：回调模式的直接链接" title="（2）异步错误处理：回调模式的直接链接">​</a></h3><p>对于异步代码，Node.js 强烈依赖两个术语：</p><ul><li>事件发射器</li><li>回调模式</li></ul><p>在回调模式中，异步 Node.js API 接受一个函数，该函数通过事件循环处理并在调用堆栈为空时立即执行。</p><p>来看下面的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const { readFile } = require(&quot;fs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function readDataset(path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  readFile(path, { encoding: &quot;utf8&quot; }, function(error, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error) console.error(error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // data操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里可以看到回调中错误处理：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function(error, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error) console.error(error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // data操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果使用 fs.readFile 读取给定路径时出现任何错误，我们都会得到一个 error 对象。这时我们可以：</p><ul><li>单地记录错误对象。</li><li>抛出异常。</li><li>将错误传递给另一个回调。</li></ul><p>要想抛出异常，可以这样做：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const { readFile } = require(&quot;fs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function readDataset(path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  readFile(path, { encoding: &quot;utf8&quot; }, function(error, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error) throw Error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // data操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>但是，与 DOM 中的事件和计时器一样，这个异常会使程序崩溃。 使用 try/catch 停止它的尝试将不起作用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const { readFile } = require(&quot;fs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function readDataset(path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  readFile(path, { encoding: &quot;utf8&quot; }, function(error, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error) throw Error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // data操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  readDataset(&quot;not-here.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果不想让程序崩溃，可以将错误传递给另一个回调：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const { readFile } = require(&quot;fs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">function readDataset(path) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  readFile(path, { encoding: &quot;utf8&quot; }, function(error, data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (error) return errorHandler(error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // data操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里的 errorHandler 是一个简单的错误处理函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">function errorHandler(error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 处理错误：写入日志、发送到外部logger</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3异步错误处理事件发射器">（3）异步错误处理：事件发射器<a href="#3异步错误处理事件发射器" class="hash-link" aria-label="（3）异步错误处理：事件发射器的直接链接" title="（3）异步错误处理：事件发射器的直接链接">​</a></h3><p>Node.js 中的大部分工作都是基于事件的。大多数时候，我们会与发射器对象和一些侦听消息的观察者进行交互。</p><p>Node.js 中的任何事件驱动模块（例如 net）都扩展了一个名为 EventEmitter 的根类。EventEmitter 有两个基本方法：on 和 emit。</p><p>下面来看一个简单的 HTTP 服务器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const net = require(&quot;net&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const server = net.createServer().listen(8081, &quot;127.0.0.1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&quot;listening&quot;, function () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&quot;Server listening!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&quot;connection&quot;, function (socket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&quot;Client connected!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  socket.end(&quot;Hello client!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们监听了两个事件：listening 和 connection。除了这些事件之外，事件发射器还公开一个错误事件，在出现错误时触发。</p><p>如果这段代码监听的端口是 80，就会得到一个异常：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const net = require(&quot;net&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const server = net.createServer().listen(80, &quot;127.0.0.1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&quot;listening&quot;, function () {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&quot;Server listening!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&quot;connection&quot;, function (socket) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.log(&quot;Client connected!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  socket.end(&quot;Hello client!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>输出结果如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">events.js:291</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw er;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      ^</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Error: listen EACCES: permission denied 127.0.0.1:80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Emitted &#x27;error&#x27; event on Server instance at: ...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了捕获它，可以为 error 注册一个事件处理函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">server.on(&quot;error&quot;, function(error) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(error.message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">});</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样就会输出：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">listen EACCES: permission denied 127.0.0.1:80</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-错误处理最佳实践">6. 错误处理最佳实践<a href="#6-错误处理最佳实践" class="hash-link" aria-label="6. 错误处理最佳实践的直接链接" title="6. 错误处理最佳实践的直接链接">​</a></h2><p>最后，我们来看看处理 JavaScript 异常的最佳实践！</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1不要过度处理错误">（1）不要过度处理错误<a href="#1不要过度处理错误" class="hash-link" aria-label="（1）不要过度处理错误的直接链接" title="（1）不要过度处理错误的直接链接">​</a></h3><p>错处理的第一个最佳实践就是<strong>不要过度使用“错误处理”</strong>。通常，我们会在外层处理错误，从内层抛出错误，这样一旦出现错误，就可以更好地理解是什么原因导致的。</p><p>然而，开发人员常犯的错误之一是过度使用错误处理。有时这样做是为了让代码在不同的文件和方法中看起来保持一致。但是，不幸的是，这些会对应用程序和错误检测造成不利影响。</p><p>因此，只关注代码中可能导致错误的地方，错误处理将有助于提高代码健壮性并增加检测到错误的机会。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2避免浏览器特定的非标准方法">（2）避免浏览器特定的非标准方法<a href="#2避免浏览器特定的非标准方法" class="hash-link" aria-label="（2）避免浏览器特定的非标准方法的直接链接" title="（2）避免浏览器特定的非标准方法的直接链接">​</a></h3><p>尽管许多浏览器都遵循一个通用标准，但某些特定于浏览器的 JavaScript 实现在其他浏览器上却失败了。例如，以下语法仅适用于 Firefox：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">catch(e) { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  console.error(e.filename + &#x27;: &#x27; + e.lineNumber); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因此，在处理错误时，尽可能使用跨浏览器友好的 JavaScript 代码。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3远程错误记录">（3）远程错误记录<a href="#3远程错误记录" class="hash-link" aria-label="（3）远程错误记录的直接链接" title="（3）远程错误记录的直接链接">​</a></h3><p>当发生错误时，我们应该得到通知以了解出了什么问题。这就是错误日志的用武之地。JavaScript 代码是在用户的浏览器中执行的。因此，需要一种机制来跟踪客户端浏览器中的这些错误，并将它们发送到服务器进行分析。</p><p>可以尝试使用以下工具来监控并上报错误：</p><ul><li><strong>Sentry（<a href="https://sentry.io/%EF%BC%89%EF%BC%9A" target="_blank" rel="noopener noreferrer">https://sentry.io/）：</a></strong> 专注于异常（应用崩溃）而不是信息错误。它提供了应用中错误的完整概述，包括受影响的用户数量、调用堆栈、受影响的浏览器以及导致错误的提交等详细信息。</li><li><strong>Rollbar（<a href="https://rollbar.com/%EF%BC%89%EF%BC%9A" target="_blank" rel="noopener noreferrer">https://rollbar.com/）：</a></strong> 用于前端、后端和移动应用的无代理错误监控工具。它提供人工智能辅助的工作流程，使开发人员能够在错误影响用户之前立即采取行动。它会显示受错误影响的客户数量、受影响的平台或浏览器的类型以及之前是否发生过类似错误或是否已经存在解决方案等数据。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4错误处理中间件nodejs">（4）错误处理中间件（Node.js）<a href="#4错误处理中间件nodejs" class="hash-link" aria-label="（4）错误处理中间件（Node.js）的直接链接" title="（4）错误处理中间件（Node.js）的直接链接">​</a></h3><p>Node.js 环境支持使用中间件向服务端应用中添加功能。因此可以创建一个错误处理中间件。使用中间件的最大好处是所有错误都在一个地方集中处理。可以选择启用/禁用此设置以轻松进行测试。</p><p>以下是创建基本中间件的方法：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const logError = err =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;ERROR: &quot; + String(err))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const errorLoggerMiddleware = (err, req, res, next) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logError(err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    next(err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const returnErrorMiddleware = (err, req, res, next) =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    res.status(err.statusCode || 500)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .send(err.message)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module.exports = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    logError,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    errorLoggerMiddleware,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    returnErrorMiddleware</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以像下面这样在应用中使用此中间件：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const { errorLoggerMiddleware, returnErrorMiddleware } = require(&#x27;./errorMiddleware&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(errorLoggerMiddleware)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">app.use(returnErrorMiddleware)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>现在可以在中间件内定义自定义逻辑以适当地处理错误。而无需再担心在整个代码库中实现单独的错误处理结构。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5捕获所有未捕获的异常nodejs">（5）捕获所有未捕获的异常（Node.js）<a href="#5捕获所有未捕获的异常nodejs" class="hash-link" aria-label="（5）捕获所有未捕获的异常（Node.js）的直接链接" title="（5）捕获所有未捕获的异常（Node.js）的直接链接">​</a></h3><p>我们可能永远无法涵盖应用中可能发生的所有错误。因此，必须实施回退策略以捕获应用中所有未捕获的异常。</p><p>可以这样做：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">process.on(&#x27;uncaughtException&#x27;, error =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;ERROR: &quot; + String(error))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 其他处理机制</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>还可以确定发生的错误是标准错误还是自定义操作错误。根据结果，可以退出进程并重新启动它以避免意外行为。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6捕获所有未处理的-promise-拒绝nodejs">（6）捕获所有未处理的 Promise 拒绝（Node.js）<a href="#6捕获所有未处理的-promise-拒绝nodejs" class="hash-link" aria-label="（6）捕获所有未处理的 Promise 拒绝（Node.js）的直接链接" title="（6）捕获所有未处理的 Promise 拒绝（Node.js）的直接链接">​</a></h3><p>与异常不同的是，promise 拒绝不会抛出错误。因此，一个被拒绝的 promise 可能只是一个警告，这让应用有可能遇到意外行为。因此，实现处理 promise 拒绝的回退机制至关重要。</p><p>可以这样做：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const promiseRejectionCallback = error =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    console.log(&quot;PROMISE REJECTED: &quot; + String(error))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">process.on(&#x27;unhandledRejection&#x27;, callback)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/hijulien/frontend/JavaScript/Promise"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Promise</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/hijulien/frontend/ES6/intro"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">ECMAScript 6 简介</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-错误概述" class="table-of-contents__link toc-highlight">1. 错误概述</a></li><li><a href="#2-错误类型" class="table-of-contents__link toc-highlight">2. 错误类型</a><ul><li><a href="#1syntaxerror" class="table-of-contents__link toc-highlight">（1）SyntaxError</a></li><li><a href="#2typeerror" class="table-of-contents__link toc-highlight">（2）TypeError</a></li><li><a href="#3referenceerror" class="table-of-contents__link toc-highlight">（3）ReferenceError</a></li><li><a href="#4rangeerror" class="table-of-contents__link toc-highlight">（4）RangeError</a></li><li><a href="#5urierror" class="table-of-contents__link toc-highlight">（5）URIError</a></li><li><a href="#6evalerror" class="table-of-contents__link toc-highlight">（6）EvalError</a></li><li><a href="#7internalerror" class="table-of-contents__link toc-highlight">（7）InternalError</a></li><li><a href="#8创建自定义错误类型" class="table-of-contents__link toc-highlight">（8）创建自定义错误类型</a></li></ul></li><li><a href="#3-抛出错误" class="table-of-contents__link toc-highlight">3. 抛出错误</a></li><li><a href="#4-抛出异常时会发生什么" class="table-of-contents__link toc-highlight">4. 抛出异常时会发生什么？</a></li><li><a href="#5-同步错误处理" class="table-of-contents__link toc-highlight">5. 同步错误处理</a><ul><li><a href="#1常规函数的错误处理" class="table-of-contents__link toc-highlight">（1）常规函数的错误处理</a></li><li><a href="#2生成器函数的错误处理" class="table-of-contents__link toc-highlight">（2）生成器函数的错误处理</a></li></ul></li><li><a href="#6-异步错误处理" class="table-of-contents__link toc-highlight">6. 异步错误处理</a><ul><li><a href="#1定时器的错误处理" class="table-of-contents__link toc-highlight">（1）定时器的错误处理</a></li><li><a href="#2事件的错误处理" class="table-of-contents__link toc-highlight">（2）事件的错误处理</a></li><li><a href="#3onerror" class="table-of-contents__link toc-highlight">（3）onerror</a></li><li><a href="#4promise-的错误处理" class="table-of-contents__link toc-highlight">（4）Promise 的错误处理</a></li><li><a href="#5promise-error-throw" class="table-of-contents__link toc-highlight">（5）Promise, error, throw</a></li><li><a href="#6使用-promise-处理定时器错误" class="table-of-contents__link toc-highlight">（6）使用 Promise 处理定时器错误</a></li><li><a href="#7promiseall-的错误处理" class="table-of-contents__link toc-highlight">（7）Promise.all 的错误处理</a></li><li><a href="#8promiseany-的错误处理" class="table-of-contents__link toc-highlight">（8）Promise.any 的错误处理</a></li><li><a href="#9promiserace-的错误处理" class="table-of-contents__link toc-highlight">（9）Promise.race 的错误处理</a></li><li><a href="#10promiseallsettled-的错误处理" class="table-of-contents__link toc-highlight">（10）Promise.allSettled 的错误处理</a></li><li><a href="#11asyncawait-的错误处理" class="table-of-contents__link toc-highlight">（11）async/await 的错误处理</a></li><li><a href="#12异步生成器的错误处理" class="table-of-contents__link toc-highlight">（12）异步生成器的错误处理</a></li></ul></li><li><a href="#5-nodejs-错误处理" class="table-of-contents__link toc-highlight">5. Node.js 错误处理</a><ul><li><a href="#1同步错误处理" class="table-of-contents__link toc-highlight">（1）同步错误处理</a></li><li><a href="#2异步错误处理回调模式" class="table-of-contents__link toc-highlight">（2）异步错误处理：回调模式</a></li><li><a href="#3异步错误处理事件发射器" class="table-of-contents__link toc-highlight">（3）异步错误处理：事件发射器</a></li></ul></li><li><a href="#6-错误处理最佳实践" class="table-of-contents__link toc-highlight">6. 错误处理最佳实践</a><ul><li><a href="#1不要过度处理错误" class="table-of-contents__link toc-highlight">（1）不要过度处理错误</a></li><li><a href="#2避免浏览器特定的非标准方法" class="table-of-contents__link toc-highlight">（2）避免浏览器特定的非标准方法</a></li><li><a href="#3远程错误记录" class="table-of-contents__link toc-highlight">（3）远程错误记录</a></li><li><a href="#4错误处理中间件nodejs" class="table-of-contents__link toc-highlight">（4）错误处理中间件（Node.js）</a></li><li><a href="#5捕获所有未捕获的异常nodejs" class="table-of-contents__link toc-highlight">（5）捕获所有未捕获的异常（Node.js）</a></li><li><a href="#6捕获所有未处理的-promise-拒绝nodejs" class="table-of-contents__link toc-highlight">（6）捕获所有未处理的 Promise 拒绝（Node.js）</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright @ 2023 The way to becoming a god.</div></div></div></footer></div>
<script src="/hijulien/assets/js/runtime~main.ab63e8e5.js"></script>
<script src="/hijulien/assets/js/main.c15d0a97.js"></script>
</body>
</html>